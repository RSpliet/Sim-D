/* SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Copyright (C) 2020 Roy Spliet, University of Cambridge
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MC_CONTROL_BACKEND_H
#define MC_CONTROL_BACKEND_H

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <cmath>
#include <cstdio>
#include <systemc>
#include <tlm>
#include <vector>
#include <list>

#include "util/defaults.h"
#include "util/constmath.h"
#include "util/csv.h"
#include "mc/control/CmdGen_DDR4.h"
#include "mc/control/CmdArb_DDR4.h"
#include "mc/control/DQ.h"
#include "model/Register.h"
#include "model/Buffer.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;
using namespace tlm;
using namespace simd_model;

namespace mc_control {

enum {
	STATS_MIN = 0,
	STATS_MAX,
	STATS_AGG
};

/** The memory controller back-end.
 *
 * From burst requests to actual DRAM commands and data movement. Generally
 * burst requests are generated by the mc_control::StrideSequencer, but it is
 * perfectly feasible to generate them from other sources (e.g.
 * mc_control::IdxIterator).
 * @param BANKS Number of DRAM banks in a chip.
 * @param COLS Number of columns per row in a DRAM chip.
 * @param ROWS Number of rows in a DRAM bank.
 * @param BUS_WIDTH Number of (32-bit) words transferred in a single DRAM burst.
 * @param THREADS Number of threads in a work-group.
 */
template <unsigned int BANKS = MC_DRAM_BANKS, unsigned int COLS = MC_DRAM_COLS,
		unsigned int ROWS = MC_DRAM_ROWS,
		unsigned int BUS_WIDTH = MC_BUS_WIDTH,
		unsigned int THREADS = COMPUTE_THREADS>
class Backend : public sc_module
{
public:
	/** DRAM clock, SDR */
	sc_in<bool> in_clk{"in_clk"};

	/** Input burst-request fifo */
	sc_fifo_in<burst_request<BUS_WIDTH,THREADS> > in_req_fifo{"in_req_fifo"};

	/** Refresh is pending */
	sc_inout<bool> out_ref_pending{"out_ref_pending"};

	/** All banks precharged */
	sc_inout<bool> out_allpre{"out_allpre"};

	/** True if currently refreshing. */
	sc_inout<bool> out_ref{"out_ref"};

	/************ Write path to(/from) Register file ****************/
	/** Index within register to read/write to. */
	sc_inout<reg_offset_t<THREADS> > out_vreg_idx_w[BUS_WIDTH/4];

	/** Mask returned by the register file that reflects active threads.
	 * Used when writing back vector registers from RF -> DRAM, to not
	 * overwrite data from disabled threads. */
	sc_inout<sc_bv<BUS_WIDTH/4> > in_mask_w{"in_mask_w"};

	/************* Read/write path to Scratchpad ***************/
	/** Scratchpad address */
	sc_inout<sc_uint<18> > out_sp_addr{"out_sp_addr"};

	/******* Lines shared between data path to Reg and SP *******/
	/** Data path is active. */
	sc_inout<bool> out_enable{"out_enable"};

	/** Scratchpad read data path */
	sc_in<sc_uint<32> > in_data[IF_SENTINEL][BUS_WIDTH/4];

	/** Data to read from register */
	sc_inout<sc_uint<32> > out_data[4];

	/** Write bit. 0: read. */
	sc_inout<bool> out_write{"out_write"};

	/** Register read/write mask. */
	sc_inout<sc_bv<BUS_WIDTH/4> > out_mask_w{"out_mask_w"};

	/** Which WG is finished.
	 * This is a FIFO to deal most efficiently with the clock-crossing domain.
	 *  */
	sc_fifo_out<RequestTarget> out_done_dst{"out_done_dst"};

	/** Cycle counter. */
	sc_inout<long> out_cycle{"out_cycle"};

private:
	/** Command generator submodule. */
	CmdGen_DDR4<BUS_WIDTH,BANKS,COLS,ROWS,THREADS> cmdgen;
	/** Command arbiter submodule. */
	CmdArb_DDR4<BUS_WIDTH,BANKS,THREADS> cmdarb;
	/** DQ scheduler submodule. */
	DQ<BUS_WIDTH,BANKS,COLS,ROWS,THREADS> dq;

	/* IdxIterator -> CmdGen */
	sc_signal<long> cycle;

	/* CmdGen -> CmdArb */
	vector<tlm_fifo<cmd_DDR<BUS_WIDTH,THREADS> > *> fifo_cmd;
	sc_signal<bool> cmdgen_busy;

	/* CmdArb -> DQ */
	sc_fifo<DQ_reservation<BUS_WIDTH,BANKS,THREADS> > fifo_dq;

	/** Wire up the subcomponents. */
	void
	elaborate(void)
	{
		unsigned int i, j;

		cmdgen.in_clk(in_clk);
		cmdgen.in_req_fifo(in_req_fifo);
		cmdgen.out_busy(cmdgen_busy);

		cmdarb.in_clk(in_clk);
		cmdarb.out_dq_fifo(fifo_dq);
		cmdarb.out_ref_pending(out_ref_pending);
		cmdarb.in_cmdgen_busy(cmdgen_busy);
		cmdarb.in_cycle(out_cycle);
		cmdarb.out_allpre(out_allpre);
		cmdarb.out_ref(out_ref);
		cmdarb.out_done_dst(out_done_dst);
		for (i = 0; i < BANKS; i++) {
			fifo_cmd[i] = new tlm_fifo<cmd_DDR<BUS_WIDTH,THREADS> >(sc_gen_unique_name("fifo_cmd"),8);

			cmdgen.out_fifo[i](*fifo_cmd[i]);
			cmdarb.in_cmd_fifo[i](*fifo_cmd[i]);
		}

		dq.in_clk(in_clk);
		dq.in_cycle(out_cycle);
		dq.in_fifo_DQ_res(fifo_dq);
		dq.out_mask_w(out_mask_w);
		dq.in_reg_mask_w(in_mask_w);
		dq.out_sp_addr(out_sp_addr);
		dq.out_enable(out_enable);
		dq.out_write(out_write);
		for (i = 0; i < BUS_WIDTH/4; i++) {
			dq.out_data[i](out_data[i]);
			dq.out_vreg_idx_w[i](out_vreg_idx_w[i]);
			for (j = 0; j < int(IF_SENTINEL); j++)
				dq.in_data[j][i](in_data[j][i]);
		}
	}

	/** Main thread */
	void
	thread_lt(void)
	{
		while (true) {
			wait();
			out_cycle.write(out_cycle.read() + 1);
		}

	}

	/** Upload CSV data from ProgramBuffer into DRAM.
	 * @param pb Program buffer. */
	void
	debug_upload_buffer_csv(const ProgramBuffer &pb)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i;
		bfloat elem;

		unsigned int addr;
		float *buf;

		words = csv_file_read_float(pb.getDataInputFile().c_str(), &buf);
		if (words < 0ul) {
			throw invalid_argument("Could not read CSV file " + pb.getDataInputFile());
		}

		words = max(words, (int64_t) (pb.dims[0] * pb.dims[1]));

		for (i = 0, addr = pb.getAddress(); i < words; i++, addr += 4) {
			cmdgen.address_translate(addr, bank, row, col);

			elem.f = buf[i];

			dq.debug_store_init(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1, elem.b);
		}

		if (buf)
			delete[] buf;
	}

	/** Upload data from ProgramBuffer into DRAM. We're handling 32-bit
	 * "binary" data, no conversion.
	 * @param pb Program buffer. */
	void
	debug_upload_buffer_bin_float(const ProgramBuffer &pb)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i;
		bfloat elem;
		ifstream *fs;
		unsigned int addr;

		fs = new ifstream(pb.getDataInputFile());

		if (!fs->is_open()) {
			throw invalid_argument("Could not read binary file " + pb.getDataInputFile());
		}

		words = (int64_t) (pb.dims[0] * pb.dims[1]);

		for (i = 0, addr = pb.getAddress(); i < words; i++, addr += 4) {
			cmdgen.address_translate(addr, bank, row, col);

			fs->read((char *)&elem.b, sizeof(float));

			dq.debug_store_init(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1, elem.b);
		}
	}
public:
	/** Constructor */
	SC_CTOR(Backend)
	: cmdgen("cmdgen"), cmdarb("cmdarb"), dq("dq"), fifo_cmd(BANKS)

	{
		elaborate();

		SC_THREAD(thread_lt);
		sensitive << in_clk.pos();
	}

	/** Upload a test pattern to DRAM.
	 * For now it just counts upwards from 0.
	 * @param addr Start address.
	 * @param words Number of words to upload. */
	void
	debug_upload_test_pattern(unsigned int addr, unsigned int words)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;

		unsigned int i;

		for (i = addr; i < addr + (words * 4); i += 4) {
			cmdgen.address_translate(i, bank, row, col);

			dq.debug_store_init(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1, i - addr);
		}
	}

	/** Upload data from ProgramBuffer into DRAM
	 * @param pb Program buffer. */
	void
	debug_upload_buffer(const ProgramBuffer &pb)
	{
		if (!pb.hasDataInputFile())
			return;

		if (pb.getDataInputType() == DECIMAL_CSV) {
			debug_upload_buffer_csv(pb);
		} else if (pb.getDataInputType() == BINARY) {
			debug_upload_buffer_bin_float(pb);
		} else {
			throw invalid_argument("Unimplemented buffer type");
		}
	}

	/** Download binary data from DRAM into an output file.
	 * @param pb Program Buffer to download data from.
	 * @param filename File to download results into. */
	void
	debug_download_buffer_bin(const ProgramBuffer &pb, string filename)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i;
		bfloat elem;
		ofstream fs(filename, ios_base::out | ios_base::trunc);

		unsigned int addr;

		if (!pb.valid)
			return;

		words = (int64_t) (pb.dims[0] * pb.dims[1]);

		for (i = 0, addr = pb.getAddress(); i < words; i++, addr += 4) {

			cmdgen.address_translate(addr, bank, row, col);

			elem.b = dq.debug_store_read(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1);

			fs.write((char *)&elem.b, sizeof(float));
		}
		fs.close();
	}

	/** Download CSV data from DRAM into an output file.
	 * @param pb Program Buffer to download data from.
	 * @param filename File to download results into. */
	void
	debug_download_buffer_csv(const ProgramBuffer &pb, string filename)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i;
		bfloat elem;
		ofstream fs(filename, ios_base::out | ios_base::trunc);

		unsigned int addr;

		if (!pb.valid)
			return;

		words = (int64_t) (pb.dims[0] * pb.dims[1]);

		for (i = 0, addr = pb.getAddress(); i < words; i++, addr += 4) {

			cmdgen.address_translate(addr, bank, row, col);

			elem.b = dq.debug_store_read(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1);

			fs << elem.f << ", ";
		}
		fs.close();
	}

	/** Compare a DRAM buffer against a provided golden output.
	 * @param pb ProgramBuffer to compare against.
	 * @param filename Name of file that contains golden values.
	 * @param delta Tolerable delta.
	 * @param pct True iff delta should be interpreted as a fractional
	 *  		difference.
	 * @return True iff the buffer matches the golden values. */
	bool
	debug_compare_buffer_bin(const ProgramBuffer &pb, string filename,
			float delta = 0.001f, bool pct = false)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i = 0ull;
		bfloat elem, gold;
		ifstream fs(filename, ios_base::in);
		unsigned int errors = 0;
		float diff;

		unsigned int addr;

		if (!fs) {
			cerr << "Error: could not open file " << filename <<
				" for buffer comparison." << endl;
			return false;
		}

		if (!pb.valid) {
			cerr << "Error: attempting to compare against invalid "
				"buffer" << endl;
			goto cmpbuf_out;
		}

		words = (int64_t) (pb.dims[0] * pb.dims[1]);

		/* i is already initialised. */
		for (addr = pb.getAddress(); i < words; i++, addr += 4) {
			fs.read((char *)&gold.b, sizeof(float));

			if (!fs) {
				if (fs.eofbit) {
					break;
				} else {
					cerr << "Error: unknown problem comparing "
						"buffer contents." << endl;
					errors++;
					break;

				}
			}

			cmdgen.address_translate(addr, bank, row, col);

			elem.b = dq.debug_store_read(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1);

			/** Calculate percentage off */
			if (pct)
				diff = fabs((elem.f / gold.f) - 1.f);
			else
				diff = fabs(gold.f - elem.f);

			if (diff > delta) {
				cerr << hex << addr << dec << ": MISMATCH " <<
					elem.f << " != " << gold.f << endl;
				errors++;
			}

			if (errors >= 10) {
				cerr << "Too many errors, quitting." << endl;
				break;
			}
		}


		if (errors == 0)
			cout << "Buffer at 0x" << hex << pb.addr << dec << ": compared "
			<< i << " words, " << errors << " errors." << endl;
		else
			cerr << "Buffer at 0x" << hex << pb.addr << dec << ": compared "
			<< i << " words, " << errors << " errors." << endl;

	cmpbuf_out:
		fs.close();

		return (errors == 0);
	}

	/** Compare a DRAM buffer against a provided golden output in CSV form.
	 * @param pb ProgramBuffer to compare against.
	 * @param filename Name of file that contains golden values.
	 * @param delta Tolerable delta.
	 * @param dfrac True iff delta should be interpreted as a fractional
	 *  		difference.
	 * @return True iff the buffer matches the golden value.
	 */
	bool
	debug_compare_buffer_csv(const ProgramBuffer &pb, string filename,
			float delta = 0.001f, bool dfrac = false)
	{
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;
		int64_t words;
		int64_t i = 0ull;
		bfloat elem, gold;
		ifstream fs(filename, ios_base::in);
		unsigned int errors = 0;
		float diff;

		unsigned int addr;

		if (!fs) {
			cerr << "Error: could not open file " << filename <<
				" for buffer comparison." << endl;
			return false;
		}

		if (!pb.valid) {
			cerr << "Error: attempting to compare against invalid "
				"buffer" << endl;
			goto cmpbuf_out;
		}

		words = (int64_t) (pb.dims[0] * pb.dims[1]);

		/* i is already initialised. */
		for (addr = pb.getAddress(); i < words; i++, addr += 4) {

			fs >> gold.f;

			if (!fs) {
				if (fs.eofbit) {
					break;
				} else {
					cerr << "Error: unknown problem comparing "
						"buffer contents." << endl;
					errors++;
					break;

				}
			}

			cmdgen.address_translate(addr, bank, row, col);

			elem.b = dq.debug_store_read(bank, row,
					col | ((addr >> 3) & 0x7),
					(addr >> 2) & 0x1);

			/** Calculate percentage off */
			if (dfrac)
				diff = fabs((elem.f / gold.f) - 1.f);
			else
				diff = fabs(gold.f - elem.f);

			if (diff > delta) {
				cerr << hex << addr << dec << ": MISMATCH " <<
					elem.f << " != " << gold.f << endl;
				errors++;
			}

			if (errors >= 10) {
				cerr << "Too many errors, quitting." << endl;
				break;
			}

			fs.ignore(numeric_limits<streamsize>::max(), ',');
		}

		if (errors == 0)
			cout << "Buffer at 0x" << hex << pb.addr << dec << ": compared "
			<< i << " words, " << errors << " errors." << endl;
		else
			cerr << "Buffer at 0x" << hex << pb.addr << dec << ": compared "
			<< i << " words, " << errors << " errors." << endl;

	cmpbuf_out:
		fs.close();

		return (errors == 0);
	}

	/** Debug: Print a range of DRAM to stdout
	 * @param addr Start address.
	 * @param words Number of words to upload. */
	void
	debug_print_range(unsigned int addr, unsigned int words)
	{
		unsigned int i;
		sc_uint<const_log2(BANKS)> bank;
		sc_uint<const_log2(ROWS)> row;
		sc_uint<const_log2(COLS)> col;

		for (i = addr; i < addr + (words * 4); i += 4) {
			cmdgen.address_translate(i, bank, row, col);

			if (!(i & 0xf))
				std::cout << std::hex << i << ": ";
			std::cout << dq.debug_store_read(bank, row,
					col | ((i >> 3) & 0x7), (i >> 2) & 0x1)
					<< " ";
			if ((i & 0xf) >= 0xc)
				 std::cout << std::dec << std::endl;
		}
	}

	/** Obtain stats from cmdarb.
	 * @param s Reference to cmdarb_stats to store results in.
	 * @param cycles Number of cycles spent on this request. */
	void
	get_cmdarb_stats(cmdarb_stats &s, unsigned int cycles = 0)
	{
		cmdarb.get_stats(s, cycles);
	}

	/** Return the clock period for the compiled RAM organisation.
	 * @return The clock period for the active DRAM organisation. */
	double
	get_clk_period(void)
	{
		return cmdarb.get_clk_period();
	}

	/** Return the clock frequency for the compiled RAM organisation.
	 * @return The clock frequency for the active DRAM organisation. */
	unsigned long
	get_freq_MHz(void)
	{
		return cmdarb.get_freq_MHz();
	}

	/**
	 * Initialise the refresh counter.
	 *
	 * This provides an easy means to vary the refresh alignment at the
	 * users discretion.
	 * @param refc Initialisation value for the refresh counter. Must be
	 * smaller than the DRAM spec's RFC.
	 */
	void
	set_refresh_counter(unsigned long refc)
	{
		cmdarb.set_refresh_counter(refc);
	}

	/** Allocate a statistics (performance counters) buffer.
	 *
	 * Allocated using mmap to make sure it can be shared across threads.
	 * @return A cmdarb_stats buffer pointer. */
	cmdarb_stats *
	allocate_cmdarb_stats()
	{
		cmdarb_stats *stats;

		/* Yay to static polymorphism... */
		stats = (cmdarb_stats *) mmap(NULL, 3 * sizeof(*stats),
				PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);

		/* MAP_ANONYMOUS: contents are initialised to zero */
		stats[STATS_MIN].act_c = UINT_MAX;
		stats[STATS_MIN].pre_c = UINT_MAX;
		stats[STATS_MIN].cas_c = UINT_MAX;
		stats[STATS_MIN].ref_c = UINT_MAX;
		stats[STATS_MIN].lda = UINT_MAX;
		stats[STATS_MIN].lid = UINT_MAX;
		stats[STATS_MIN].power = UINT_MAX;
		stats[STATS_MIN].energy = UINT_MAX;

		return stats;
	}

	/** Free a statistics (performance counters) buffer.
	 * @param stats Pointer to the cmdarb_stats object to free. */
	void
	free_cmdarb_stats(cmdarb_stats *stats)
	{
		munmap((void *)stats, 3 * sizeof(*stats));
	}

	/** Aggregate the stats in the .
	 * @param stats Pointer to the aggregation targets, array of three
	 * 		cmdarb_stats objects.
	 * @param s Reference to cmdarb_stats object containing data for this
	 * 	    single run. */
	void
	aggregate_cmdarb_stats(cmdarb_stats *stats, cmdarb_stats &s)
	{
		stats[STATS_MIN].min(s);
		stats[STATS_MAX].max(s);
		stats[STATS_AGG].aggregate(s);
	}

	/** Debug: print out the aggregate statistics to stdout.
	 * @param stats Pointer to an array of three cmdarb_stats objects
	 * 		containing the aggregate values. */
	void
	print_aggregate_cmdarb_stats(cmdarb_stats *stats)
	{
		cout << "=== Aggregate stats ===" << endl;
		cout << "Latest data arrival  : " << setw(10) << stats[STATS_MIN].lda
					<< setw(10) << stats[STATS_MAX].lda << endl;
		cout << "Least-issue delay    : " << setw(10) << stats[STATS_MIN].lid
					<< setw(10) << stats[STATS_MAX].lid << endl;
		cout << "# Read/write ops     : " << setw(10) << stats[STATS_MIN].cas_c
					<< setw(10) << stats[STATS_MAX].cas_c << endl;
		cout << "# Activate ops       : " << setw(10) << stats[STATS_MIN].act_c
					<< setw(10) << stats[STATS_MAX].act_c << endl;
		cout << "# Explicit PRE ops   : " << setw(10) << stats[STATS_MIN].pre_c
					<< setw(10) << stats[STATS_MAX].pre_c << endl;
		cout << "# Refresh ops        : " << setw(10) << stats[STATS_MIN].ref_c
					<< setw(10) << stats[STATS_MAX].ref_c << endl;

		cout << "# Total energy (pJ)  : " << setw(10) << stats[STATS_MIN].energy
				<< setw(10) << stats[STATS_MAX].energy << endl;
		cout << "# Average power (mW) : " << setw(10) << stats[STATS_MIN].power
				<< setw(10) << stats[STATS_MAX].power << endl;
	}
};

}

#endif /* MC_CONTROL_BACKEND_H */
