/* SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Copyright (C) 2020 Roy Spliet, University of Cambridge
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <https://www.gnu.org/licenses/>.
 */

#include <systemc>
#include <list>
#include <cstdio>

#include <ramulator/DDR4.h>

#include "mc/control/Backend.h"
#include "mc/control/StrideSequencer.h"

#include "sp/control/Scratchpad.h"

#include "model/stride_descriptor.h"

#include "util/constmath.h"
#include "util/defaults.h"
#include "util/debug_output.h"

using namespace mc_model;
using namespace mc_control;
using namespace sp_control;
using namespace std;
using namespace sc_core;
using namespace sc_dt;

enum {
	STATS_MIN = 0,
	STATS_MAX,
	STATS_AGG
};

namespace mc_test {

/** Unit test for mc */
class Test_mc : public sc_module
{
private:
	bool write;

	sc_uint<32> base_addr;

public:
	/** DRAM clock, SDR */
	sc_in<bool> in_clk{"in_clk"};

	/** Signal indicating IndexIterator is done with its current job */
	sc_fifo_in<RequestTarget> in_done_dst{"in_done_dst"};

	/** The next address as normally generated by the stride sequencer. */
	sc_fifo_out<bool> out_trigger{"out_trigger"};

	/** FIFO of descriptors
	 * @todo Depth? */
	sc_fifo_out<idx_t<COMPUTE_THREADS> > out_idx{"out_idx"};

	/** FIFO of descriptors
	 * @todo Depth? */
	sc_fifo_out<stride_descriptor> out_desc{"out_desc"};

	sc_inout<sc_bv<WSS_SENTINEL>> out_sched_opts{"out_sched_opts"};

	/** Ticket number for next stride_descriptor ready to pop off
	 * DRAM/SPs FIFOs. */
	sc_inout<sc_uint<4> > out_ticket_pop{"out_ticket_pop"};

	/** Construct test thread */
	SC_CTOR(Test_mc) : write(0)
	{
		SC_THREAD(thread_lt);
		sensitive << in_clk.pos();
	}

	/** Enqueue an index on the in-fifo.
	 * @param idx index to enqueue.*/
	void
	enqueue_idx(idx_t<COMPUTE_THREADS> idx)
	{
		out_idx.write(idx);
	}

	/** Set the base address
	 * @param base_addr Base address in DRAM for buffer. */
	void
	set_base_addr(sc_uint<32> b)
	{
		base_addr = b;
	}

	void
	set_write(bool w)
	{
		write = w;
	}

private:
	/** Main thread */
	void
	thread_lt(void)
	{
		sc_bv<WSS_SENTINEL> sched_opts;
		AbstractRegister t(0,REGISTER_VGPR,0);
		stride_descriptor idxdesc(t);

		idxdesc.type = stride_descriptor::IDXIT;
		idxdesc.addr = base_addr;
		idxdesc.write = write;
		idxdesc.dst_offset = 0;
		out_desc.write(idxdesc);

		sched_opts = 0;
		sched_opts[WSS_STOP_DRAM_FINI] = Log_1;

		out_sched_opts.write(sched_opts);
		out_ticket_pop.write(0);

		out_trigger.write(1);
		wait();
		out_trigger.write(0);

		while (1) {
			if (in_done_dst.num_available())
				in_done_dst.read();

			wait();
		}
	}
};

}

using namespace mc_control;
using namespace mc_test;
using namespace ramulator;

static int sweep_alignment = false;

/* SystemC: Full system */
static sc_clock *clk;

static Test_mc test("test");
static mc_control::StrideSequencer<MC_BUS_WIDTH,COMPUTE_THREADS> sseq("sseq");
static Backend<MC_DRAM_BANKS,MC_DRAM_COLS,MC_DRAM_ROWS> mc("mc");
static sp_control::Scratchpad<0,MC_BUS_WIDTH/4,SP_BUS_WIDTH,131072,COMPUTE_THREADS> sp("sp");

/* IdxIterator -> CmdGen */
static sc_fifo<stride_descriptor> desc_fifo;
static sc_fifo<burst_request<MC_BUS_WIDTH,COMPUTE_THREADS> > req_fifo(MC_BURSTREQ_FIFO_DEPTH);
static sc_signal<bool> dangle_strseq_done;
static sc_fifo<bool> strseq_trigger(2);
static sc_signal<RequestTarget> strseq_dst;
static sc_signal<sc_bv<WSS_SENTINEL> > test_sched_opts;
static sc_signal<sc_uint<4> > test_ticket_pop;

static sc_signal<bool> ref_pending;
static sc_fifo<RequestTarget> mc_done_dst;
static sc_signal<bool> mc_allpre;
static sc_signal<AbstractRegister> sseq_vreg_reg_w;
static sc_signal<bool> mc_enable;
static sc_signal<reg_offset_t<COMPUTE_THREADS> > mc_vreg_idx_w[MC_BUS_WIDTH/4];

static sc_signal<bool> sseq_idx_push_trigger;
static sc_fifo<idx_t<COMPUTE_THREADS> > sseq_idx(32);

static sc_signal<bool> mc_vreg_rw;

static sc_signal<sc_uint<32> > mc_out_data[MC_BUS_WIDTH/4];
static sc_signal<bool> mc_write;
static sc_signal<sc_uint<18> > mc_sp_addr;
static sc_signal<sc_uint<2> > mc_sp_words;
static sc_signal<long> mc_cycle;
static sc_signal<bool> dangle_mc_ref;

static sc_signal<sc_bv<MC_BUS_WIDTH/4> > mc_mask_w;
static sc_signal<sc_bv<MC_BUS_WIDTH/4> > mc_imask_w;
static sc_signal<sc_uint<32> > sp_data_mc[SP_BUS_WIDTH];

static sc_fifo<stride_descriptor> dangle_sp_desc_fifo;
static sc_fifo<bool> dangle_sp_trigger(2);
static sc_fifo<sc_uint<1> > dangle_sp_wg_done;
static sc_signal<bool> dangle_sp_rf_enable;
static sc_signal<bool> dangle_sp_rf_write;
static sc_signal<AbstractRegister> dangle_sp_rf_reg;
static sc_signal<sc_bv<SP_BUS_WIDTH> > dangle_sp_rf_mask;
static sc_signal<sc_bv<SP_BUS_WIDTH> > dangle_sp_in_rf_mask;
static sc_signal<reg_offset_t<COMPUTE_THREADS> > dangle_sp_rf_idx[SP_BUS_WIDTH];
#if SP_BUS_WIDTH != (MC_BUS_WIDTH/4)
	sc_signal<sc_uint<32> > sp_out_data[SP_BUS_WIDTH-(MC_BUS_WIDTH/4)];
#endif
static sc_signal<sc_uint<32> > dangle_regfile_store_data[SP_BUS_WIDTH];

static sc_signal<sc_uint<32> > dangle_data_mc[2][SP_BUS_WIDTH];

/** Wire up the design
 */
void
elaborate()
{
	unsigned int i;

	clk = new sc_clock("clk", sc_time(mc.get_clk_period(), SC_NS));

	test.in_clk(*clk);
	test.in_done_dst(mc_done_dst);
	test.out_trigger(strseq_trigger);
	test.out_desc(desc_fifo);
	test.out_idx(sseq_idx);
	test.out_sched_opts(test_sched_opts);
	test.out_ticket_pop(test_ticket_pop);

	sseq.in_clk(*clk);
	sseq.in_desc_fifo(desc_fifo);
	sseq.in_ref_pending(ref_pending);
	sseq.in_trigger(strseq_trigger);
	sseq.out_req_fifo(req_fifo);
	sseq.out_done(dangle_strseq_done);
	sseq.in_DQ_allpre(mc_allpre);
	sseq.out_dst(strseq_dst);
	sseq.out_dst_reg(sseq_vreg_reg_w);
	sseq.out_idx_push_trigger(sseq_idx_push_trigger);
	sseq.in_idx(sseq_idx);
	sseq.in_cycle(mc_cycle);
	sseq.in_sched_opts(test_sched_opts);
	sseq.in_ticket_pop(test_ticket_pop);

	mc.in_clk(*clk);
	mc.in_req_fifo(req_fifo);
	mc.out_ref_pending(ref_pending);
	mc.out_allpre(mc_allpre);
	mc.out_ref(dangle_mc_ref);
	mc.in_mask_w(mc_imask_w);
	mc.out_sp_addr(mc_sp_addr);
	mc.out_enable(mc_enable);
	mc.out_write(mc_write);
	mc.out_mask_w(mc_mask_w);
	mc.out_done_dst(mc_done_dst);
	mc.out_cycle(mc_cycle);
	for (unsigned int i = 0; i < 4; i++) {
		mc.out_data[i](mc_out_data[i]);
		mc.in_data[IF_SP_WG0][i](sp_data_mc[i]);
		mc.in_data[IF_SP_WG1][i](dangle_data_mc[0][i]);
		mc.in_data[IF_RF][i](dangle_data_mc[1][i]);
		mc.out_vreg_idx_w[i](mc_vreg_idx_w[i]);
	}

	sp.in_clk(*clk);
	sp.in_sched_opts(test_sched_opts);
	sp.in_ticket_pop(test_ticket_pop);
	sp.in_desc_fifo(dangle_sp_desc_fifo);
	sp.in_trigger(dangle_sp_trigger);
	sp.out_wg_done(dangle_sp_wg_done);
	sp.out_rf_enable(dangle_sp_rf_enable);
	sp.out_rf_write(dangle_sp_rf_write);
	sp.out_rf_reg(dangle_sp_rf_reg);
	sp.out_rf_mask(dangle_sp_rf_mask);
	sp.in_rf_mask(dangle_sp_in_rf_mask);
	/** @todo in_rf_mask -> regfile_store_mask[IF_SP_WG0] */
	sp.in_dram_enable(mc_enable);
	sp.in_dram_dst(strseq_dst);
	sp.in_dram_write(mc_write);
	sp.in_dram_addr(mc_sp_addr);
	sp.in_dram_mask(mc_mask_w);

	for (i = 0; i < MC_BUS_WIDTH/4; i++) {
		sp.out_data[i](sp_data_mc[i]);
		sp.in_dram_data[i](mc_out_data[i]);
	}

	for (i = 0; i < SP_BUS_WIDTH; i++) {
		sp.out_rf_idx[i](dangle_sp_rf_idx[i]);
		sp.in_rf_data[i](dangle_regfile_store_data[i]);
	}

#if SP_BUS_WIDTH != (MC_BUS_WIDTH/4)
	for (i = 0; i < SP_BUS_WIDTH - (MC_BUS_WIDTH/4); i++)
		sp.out_data[(MC_BUS_WIDTH/4)+i](sp_out_data[i]);
#endif
	sp.elaborate();
}

/** Execute simulation
 * @param descs List of descriptors to pre-load the fifo with
 */
void
do_sim(list<idx_t<COMPUTE_THREADS> *> idxs, cmdarb_stats *stats)
{
	cmdarb_stats s;
	/* Enqueue stride patterns */
	for (idx_t<COMPUTE_THREADS> *idx : idxs)
		test.enqueue_idx(*idx);

	/* Pre-fill scratchpad and DRAM */
	/** @todo We should probably read these patterns from a file too... */
	sp.debug_upload_test_pattern(0, 1024);
	mc.debug_upload_test_pattern(0x140000, 1024);

	/* Run */
	sc_core::sc_start();

	/* Print out chunks of memory touched by the (static) test */
	//mc.debug_print_range(0x140000, 1536, &cmdgen, &dq);
	//sp.debug_print_range(0x0, 256);
	mc.get_cmdarb_stats(s);
	mc.aggregate_cmdarb_stats(stats, s);
	if (debug_output[DEBUG_CMD_STATS]) {
		cout << s << endl;
	}
}

/** Document the parameters accepted by this binary.
 * @param Program name binary name used to invoke this program. */
void
help(char *program_name)
{
	cout << program_name << endl;
	cout << "Simulate iterative indexed read/write DRAM operations." << endl;
	cout << endl;
	cout << "Options:" << endl;
	cout << "\t-f [file]:\tSpecify an input file with word off-sets within"
			<< endl;
	cout << "\t\t\tthe buffer. Provide - to read from stdin (pipe)." << endl;
	cout << "\t-w:\t\tSimulate an indexed write operation." << endl;
	cout << "\t-t:\t\tOutput (CmdArb) command emission trace." << endl;
	cout << "\t-p:\t\tOutput (CmdArb) summary." << endl;
	cout << "\t-b [addr]:\tBase address (default: 0x0)." << endl;
	cout << "\t-S:\t\tSweep DRAM address over all possible alignments."
			<< endl;
	cout << "\t-h:\t\tThis help." << endl;
}

/** Parse command line parameters
 * @param argc Number of parameters given
 * @param argv List of strings, each containing one parameter
 * @param test The unit-test SystemC object connected to the top level of the
 * 	       memory controller
 */
void
parse_parameters(int argc, char* argv[], list<idx_t<COMPUTE_THREADS> *> *idxs,
		sc_uint<32> *base_addr, bool *write)
{
	FILE *f;
	uint32_t ba;
	int c;
	int i;
	unsigned int idx;
	list<idx_t<COMPUTE_THREADS> >::reverse_iterator xit;

	/* Take stride patterns from the command line */
	while ( (c = getopt(argc, argv, "f:tpb:Sw")) != -1) {
		switch (c) {
		case 'f':
			if (optarg[0] == '-')
				f = stdin;
			else
				f = fopen(optarg, "r");
			if (!f) {
				std::cout << "File not found: " << optarg <<
						std::endl;
				help(argv[0]);
				exit(1);
			}

			i = 0;
			while (fscanf(f,"%u", &idx) == 1) {
				idxs->push_back(new idx_t<COMPUTE_THREADS>(i++,idx));
			}
			idxs->push_back(new idx_t<COMPUTE_THREADS>());
			fclose(f);
			f = nullptr;

			break;
		case 't':
			debug_output[DEBUG_CMD_EMIT] = 1;
			break;
		case 'p':
			debug_output[DEBUG_CMD_STATS] = 1;
			break;
		case 'b':
			i = sscanf(optarg, "%x", &ba);
			*base_addr = ba;
			break;
		case 'S':
			sweep_alignment = true;
			break;
		case 'w':
			*write = true;
			break;
		default:
			help(argv[0]);
			exit(1);
		}
	}
}

/** Main SystemC thread.
 * @param argc Number of strings in argv.
 * @param argv Command-line parameters.
 * @return 0 iff program ended successfully.
 */
int
sc_main(int argc, char* argv[])
{
	list<idx_t<COMPUTE_THREADS> *> idxs;
	sc_uint<32> base_addr = 0;
	int pid;
	int i, i_max = 1;
	bool write = false;
	cmdarb_stats *stats;

	/* Now that test is set up correctly, we can start parsing params */
	parse_parameters(argc, argv, &idxs, &base_addr, &write);

	/* MC_DRAM_COLS * 2 for number of words, * 2 for interleaved banks */
	if (sweep_alignment)
		i_max = MC_DRAM_COLS * 4;

	elaborate();
	test.set_write(write);
	stats = mc.allocate_cmdarb_stats();

	for (i = 0; i < i_max; i++) {
		pid = fork();
		if (pid == 0) {
			test.set_base_addr(base_addr + (i * 4));
			do_sim(idxs, stats);
			exit(0);
		}

	        waitpid(pid, NULL, 0);
	}

	/* Print aggregates */
	mc.print_aggregate_cmdarb_stats(stats);

	mc.free_cmdarb_stats(stats);

	return 0;
}
